<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>AEMAPs | R5: Development Guide</title>
<!-- --------------------------------------------------------------------------------------------------------------- -->
<style>
	body {
		font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji";
		font-size: 14px;
		color: #24292f;
	}
	code {
	  padding: 0;
	}
</style>
<!-- https://github.com/oscarmorrison/md-page -->
<!-- <script src="https://rawcdn.githack.com/oscarmorrison/md-page/master/md-page.js"></script> -->
<!-- https://github.com/oscarmorrison/md-page/blob/d6eb4109199b038a526598c51dd005274c8e9589/md-page.js -->
<script src="https://cdn.jsdelivr.net/gh/oscarmorrison/md-page@d6eb4109/md-page.js"></script>
<noscript>
</head>
<!-- --------------------------------------------------------------------------------------------------------------- -->
<body>

# AEMAPs | R5: Руководство разработчика

## Структура проекта

Архитектура проекта представляет собой фреймворк из трех компонентов:

### Библиотека общего назначения

Самостоятельный проект, подгружается ядром как внешний модуль при первом запуске.
- *Для смены версии необходимо перезапустить AE.*

Со списком доступных методов можно ознакомиться в [aedt/README.md](https://github.com/DT-Design-Technologies/AEMAPs/blob/production/aedt/README.md)

### Ядро

Выполняет следующие задачи:

- Загрузка конфигураций
- Отрисовка UI
- Подготовка проекта AE на базе шаблона и выбранной конфигурации
- Построение абстрактного дерева, соответствующего загруженному `.psd`
- Инициализация окружения и вызов внешних модулей для каждого узла дерева
- Сообщения об ошибках

Ядро может быть загружено как модуль стороннего сервиса. Для этого ему следует передать переменную `passThrough`, содержащую функцию подготовки данных.

```js
	var passThrough = function() {											//передаются аргументы стороннего сервиса
		var ui = makeUI();													//создает скрытый UI и возвращает объект {form,data,flags,env}
		var err = setContent(ui.data.read(), ui.flags.read(), ui.env);		//запускает работу и возвращает коллекцию ошибок {err}
	};

	$.evalFile("AEMAPs.jsx");												//в режиме модуля ядро возвращает метод
```

### Внешние модули

Выполняют действия над загруженным `.psd`

Имя модуля соответствует тегу обработчика узла в абстрактном дереве.
- *Имя не должно содержать символов `_`.*
- *Все имена приводятся к верхнему регистру.*

Допускаются следующие форматы:
- `.jsxinc` - интерпретируется как тело функции
- `.jsx|.jsxbin` - при загрузке вызывается как функция в контексте загрузчика, должна возвращать метод
- `.ffx` - стандартный пресет AE

Специальный модуль `INIT` при наличии вызывается один раз перед построением дерева.
- Ядро передает в `INIT` объект, содержащий общие параметры окружения.

```js
{
	_main : {
		_hList										//массив обработчиков, загруженный для выбранной конфигурации
		_config										//объект выбранного шаблона конфигурации

		_flags : {
			mode									//флаг выбранного режима обработки
			is3D									//флаг выбранной размерности
			isText									//флаг опции конвертации текстовых слоев
		}

		cContent									//корневая композиция шаблона (опционально)
		lCam										//активная камера корневой композиции (опционально)
		lCtrl										//управляющий камерой слой верхнего уровня (опционально)
		lScreen										//слой композиции в плоскости экрана (опционально)

		cRoot										//композиция, содержащая корень дерева
		lRoot										//слой - корень дерева
		
		_fPre										//массив функций предварительной обработки узла дерева
		_fPost										//массив функций постобработки узла дерева
		_err										//объект сбора ошибок (см. aedt/COMMON INVENTORY)

		_tree										//массив корневых узлов уже построенных деревьев (опционально)
		_plant										//альтернативный корневой узел текущего дерева, будет записан в _tree вместо null
	},

	_exec : {
		_setup(_layer, _ansector)					//метод сборки контекста объекта
		_wrap(_setup)								//метод сборки узла дерева
		_handle(_env, _exch, _stage)				//метод вызова обработчика
		_update(_env, _exch)						//метод сборки/обновления ветви дерева
	}
}
```

- Этот объект передается далее в качестве аргумента при вызове каждого обработчика, таким образом `INIT` можно использовать для формирования окружения или как локальную библиотеку.

- В случае обнаружения флага отмены сканирования `INIT` передает управление специальному модулю `UPDATE` при наличии. Его задача подменить корневой узел текущего дерева альтернативным.

Специальный модуль `DEFAULT` при наличии вызывается для каждого узла с неуказанным или несуществующим обработчиком.

Специальный модуль `FINAL` при наличии вызывается один раз после построения всех деревьев.
- Ядро передает в `FINAL` объект `_main` с измененными параметрами.

```js
{
	...

	lRoot						//слой - корень дерева или массив слоев
	_fPre : null
	_fPost : null
	_tree						//корневой узел или массив корневых узлов построенных деревьев
}
```

## Создание модуля

Вызов всех обработчиков, кроме `INIT`, `FINAL` и `UPDATE`, происходит по следующей схеме:

```js
	SETUP.handler(PARAMS, stage)
```

Обход дерева происходит в два прохода: при его построении (`stage == 'scan'`) и при обработке (`stage == 'operate'`).
Таким образом, каждый обработчик вызывается дважды, что позволяет при необходимости произвести предварительные действия в проекте до вызова основного обработчика.
Направление обхода сначала в порядке увеличения уровня вложенности, затем от первого слоя к последнему на каждом уровне.

Объект типа `SETUP` представляет собой контекст обрабатываемого слоя и доступен через ключевое слово `this`.

```js
{
	layer						//ссылка на обрабатываемый слой
	lchain						//массив имен слоев, начиная от имени композиции cRoot, до имени текущего слоя

	ltag						//тег обработчика
	lvar						//тег идентификации

	start						//время начала в секундах
	end							//время окончания или 0
	gstart						//время начала в пересчете на cRoot
	dur							//длительность (как правило, ненулевое значение предполагает закрытие реверсом анимации, а нулевое соответствует выходу на стоп-кадр)

	rot							//поворот в градусах

	layer.comment : '_parsed_'	//флаг отмены сканирования текущего слоя (выставляется автоматически для предотвращения повторного сканирования после изменения стека слоев)
}
```

Каждый узел дерева представляет собой объект типа `WRAPPER`, в который завернут соответствующий `SETUP`.

```js
{
	container : SETUP			//ссылка на контекст слоя
	comp						//композиция слоя (container.layer.source)

	parent : WRAPPER			//ссылка на родительский узел дерева (выставляется на этапе сканирования)
	content : [WRAPPER]			//массив ссылок на дочерние узлы дерева (заполняется на этапе сканирования)

	stop_recursion				//флаг отмены обхода вложенных объектов на обеих стадиях (обычно используется после операции прекомпозиции)
	parsed						//флаг отмены вызова обработчика текущего объекта (обычно используется, если все необходимые действия совершены)

	_parsed_					//флаг отмены обработки текущего объекта ядром (выставляется автоматически для предотвращения повторного вызова функции постобработки)
}
```

Объект `PARAMS` включает в себя, помимо общих параметров, полученных от ядра, и дополнительных, добавленных в `INIT`, два параметра окружения для данного слоя.

```js
{
	...							//_main, _exec,..

	_env : WRAPPER				//ссылка на узел дерева, соответствующий слою-контейнеру
	_exch : WRAPPER				//ссылка на узел дерева, соответствующий текущему слою
}
```

Такая архитектура позволяет расширять объект обрабатываемого узла произвольным набором параметров для передачи их всем объектам на следующем уровне вложенности.

<!-- --------------------------------------------------------------------------------------------------------------- -->
&nbsp;

---

## Расширения специальных модулей

Модуль `INIT` по умолчанию предлагает набор инструментов для решения типовых задач в рамках создания обработчика.

### Методы общего назначения

```js
{
	...

	_exec : {
		...

		bind(_sbj, _obj)		//выполняет привязку определенных SETUP/PARAMS для всех расширений _exec, либо добавляет один из предопределенных methods к WRAPPER
		call(_tag)				//вызывает произвольный обработчик с текущими параметрами, без указания stage
		err(_msg)				//добавляет в стек ошибок новую запись с текущими параметрами, по умолчанию сообщение об отсутствии геометрии
		sets(_func)				//перебирает найденные для текущего _exch источники геометрии с вызовом _func(idx,set)
		content(_func)			//рекурсивно обходит узлы поддерева, начиная с текущего _exch, с вызовом _func(depth,idx,xch)
		source(_func)			//рекурсивно обходит вложенные слои, начиная с текущего, с вызовом _func(depth,idx,layer)
	}
}
```

- *Под «текущими» в рамках семантики коллекции `_exec` здесь и далее понимаются сущности, соответствующие контексту и параметрам, выставленным с помощью `_exec.bind(SETUP, PARAMS)`.*

### Поиск геометрии

```js
	_exec.geometry(_gm, _alt)
```

Метод пытается рассчитать геометрию текущего объекта на основании основного или альтернативного набора аргументов:

```js
	[
		_lname,					//фильтр слоев, (undef)|(str)|RE; undef -> _main._config.gm
		_fMask,					//фильтр масок, (undef)|bool|func(mask); undef -> true
		_delta,					//допустимое отклонение, (undef)|px; undef -> _main._config.gmdelta
		_rot					//поворот, (undef)|num, определяет только способ расчета: num|true -> 2 (via global), 0|false|parent -> 1 (via local), null|undef -> 0 (ignore)
	]
```

- *Неопределенное значение поворота `SETUP.rot` при расчете ведет к игнорированию пространственных преобразований с целью оптимизации. Для принудительного выполнения таких преобразований следует инициализировать соответствующий аргумент в `0`.*

Результат сохраняется как свойство `geometry` текущего `_exch` и представляет собой объект вида:

```js
{
	own|rel|ext : {				//параметры bounding box объекта в пространствах layer|parent|world
		lt						//левый верхний угол
		rt						//правый верхний угол
		rb						//правый нижний угол
		w						//ширина
		h						//высота
		c						//геометрический центр
		vx						//единичный вектор по горизонтали
		vy						//единичный вектор по вертикали
		ap						//апекс (выступающая точка или центр)
		par						//pixel aspect ratio
	}

	edge						//расположение апекса, 'left'|'top'|'right'|'bottom'|'center'

	sets : [					//источники геометрии
		own|rel|ext				//параметры bounding box источника в пространствах объекта
		edge					//расположение апекса источника
		src : {					//внутренние параметры
			layer				//ссылка на слой источника
			lchain				//массив имен слоев, начиная от имени композиции, содержащей объект, до имени слоя источника
			own|rel|ext			//параметры bounding box источника в пространствах слоя
		}
	]
}
```

- *В зависимости от способа расчета и выполненных пространственных преобразований размерность параметров bounding box может быть различной.*

Инструмент для проведения предварительного поиска объектов `TAG` среди дочерних узлов `WRAPPER` без вызова собственных обработчиков. Предназначен для использования в групповых обработчиках.

```js
	WRAPPER.preload(
		_tag,					//тег искомого объекта, 'TAG'
		_lag,					//задержка для связанных объектов, sec|'frm'
		_sort,					//аргументы для сортировки результатов, (bool)|['.prop'|['.prop',dir]|func(a,b)]; true -> lvar asc & idx desc
		_gm						//аргументы для расчета геометрии, ('nogm'|undef)|[args], альтернативный набор не поддерживается
	)
```

- *Метод предопределен в коллекции `methods` и должен быть предварительно привязан к узлу с помощью `_exec.bind('preload', WRAPPER)`.*

Результат сохраняется как свойство `TAG` или `TAGs` узла `WRAPPER` и представляет собой ссылку или массив ссылок на соответствующие узлы, дополненные следующим набором параметров:

```js
{
	...

	geometry					//геометрия искомого объекта
	lag							//задержка для связанных объектов в секундах
	num							//0 или нумерация в соответствии с сортировкой от 1
}
```

### Объект `ANIMATOR`

Инструмент для комплексного управления анимацией элементов.

```js
	_exec.animator(
		_delay,					//собственная задержка анимации для текущего объекта, учитывается при закрытии, игнорируется при наличии явного тайминга, sec|'frm'
		_tdur,					//базовая длительность анимации для текущего объекта, учитывается при закрытии, игнорируется при наличии альтернативной, знак определяет направление анимации, sec|'frm'
		_lag					//дополнительная итеративная внутренняя задержка для источников геометрии текущего объекта, не учитывается при закрытии, sec|'frm'
	)
```

- *Beta: допускается указание дополнительной внешней задержки в секундах через параметр `delay` текущего `_exch`, не учитывается при закрытии.*

Конструктор создает объект и сохраняет его как свойство `Animator` текущего `_exch`.

Прикладные методы `Animator` работают с внутренним контекстом `adata`, связанным с конкретным слоем из составляющих текущий объект:

```js
{
	base						//ссылка на узел WRAPPER базового слоя
	prnt						//ссылка на родительский узел base

	ctx							//ссылка на контекст SETUP базового слоя
	gm							//собственная геометрия текущего объекта или базового слоя, или соответствующий этому слою источник геометрии (внутренние параметры sets[i].src)
	lbase						//ссылка на базовый слой

	ts							//предполагаемое время начала с учетом входных параметров в локальном тайминге базового слоя
	te							//предполагаемое время окончания с учетом входных параметров в локальном тайминге базового слоя

	bmask						//ссылка на маску 'cropper', появляется после маскировки базового слоя
	lmask						//ссылка на alpha mask слой, появляется после маскировки базового слоя в режиме 2
	cmask						//ссылка на прекомпозицию, появляется после маскировки базового слоя в режиме 3
}
```

- *Под «базовыми» в рамках семантики объекта `Animator` здесь и далее понимаются сущности, соответствующие установленному внутреннему контексту.*

Переключение внутреннего контекста можно производить по индексу или другим свойствам источника геометрии, по ссылке на узел или слой.

```js
	Animator.sortGM(_sort)		//сортировка источников геометрии, _sort = (undef)|-1|'.prop'|['.prop',dir]|func(a,b); undef -> NM asc & S desc & idx desc
	Animator.setBase(_fSel)		//установка внутреннего контекста, _fSel = (undef)|idx|func(set)|{xch}|L; undef -> self
```

Группа методов для проведения подготовительных действий в сцене:

```js
	Animator.makeCopy(_name, _clrM, _clrE)			//создает копию базового слоя с установкой родительского, очищает ее от стилей, масок и эффектов, возвращает ссылку на копию
	Animator.maskBase(_mtype)						//маскирует базовый слой различными способами, используется первая маска или bounding box, _mtype = 0|1|2|3 -> 1st|bbox|alpha|precomp, ссылки сохраняет в adata
	Animator.maskOther(_rgxp, _altP, _isPrnt)		//маскирует соседние слои копией базового, связывает свойства масок (по умолчанию все слои без геометрии и maskPath), устанавливает родительский слой

	Animator.getShift(_space, _mult, _add)			//вычисляет модифицированный по осям геометрический сдвиг в пространствах базового слоя 'own|ext|rel', исходя из габаритов bounding box базового слоя, возвращает массив из 3 элементов
```

Перед выполнением анимации необходимо добавить соответствующее свойство во внутреннюю очередь. Для каждого свойства можно настроить индивидуальные параметры анимации.

```js
	Animator.setProp(			//метод возвращает индекс добавленного в очередь элемента
		_fProp,					//ссылка на свойство, соответствующее нужному контексту, или массив ссылок, или функция po.func(adata,sres)
		_fVal,					//значение, соответствующее свойству, или функция po.func(prop,start,dur)

		_altT = [				//альтернативный тайминг; undef -> базовый тайминг с реверсом закрытия
			sdl,				//дополнительное смещение момента начала, учитывается при закрытии, sec|'frm'
			tdr,				//альтернативная длительность, учитывается при закрытии, знак определяет направление анимации, sec|'frm'
			nor					//флаг отключения реверса закрытия, -1 для интерпретации как анимации выхода
		],

		_inflOI,				//степень интерполяции на границах перехода, (undef|0)|[(null|0)|('default'|'in'|'out')|num]; undef|null -> [50,75], 0 -> linear, 'default' -> 100/3
		_spdOI					//скорость на границах перехода, (undef)|[(undef)|num]; undef -> ['in','out']
	)
```

- Контекст вызова функций `_fProp` и `_fVal` представляет собой элемент очереди `po`:

```js
{
	ref							//ссылка на внутренний контекст adata, установленный на момент постановки в очередь

	prp							//_fProp
	val							//_fVal

	sdl
	tdr							//абсолютное значение
	dir							//истинное направление анимации, по умолчанию -1 (от полученного значения к начальному)
	nor

	ifl							//_inflOI
	spd							//_spdOI
}
```

- Передаваемые и возвращаемые параметры:

```js
	_fProp(						//функция должна вернуть свойство или массив, или null для прерывания работы (произвольные действия вне аниматора)
		adata,					//ссылка на внутренний контекст, установленный на момент вызова
		sres					//информация о параметрах комплексного применения анимации (bool или результат _fSel)
	)

	_fVal(						//функция должна вернуть значение или undefined для пропуска блока открытия (анимация вне аниматора с реверсом закрытия)
		prop,					//полученная ссылка на свойство
		start,					//истинное значение момента начала анимации в локальном тайминге базового слоя
		dur						//истинное абсолютное значение длительности анимации
	)
```

После проведенного блока анимации перед сменой внутреннего контекста может потребоваться очистить очередь целиком или удалить из нее конкретные элементы.

```js
	Animator.clrProp(_idx)		//_idx = (undef)|idx|[idx]
```

Для фактического применения анимации текущей очереди к базовому слою необходимо использовать следующий метод:

```js
	Animator.applyBase(_sres)	//аргумент передается в _fProp
```

Для применения анимации текущей очереди сразу к группе элементов следует воспользоваться одним из комплексных методов.

```js
	Animator.applySets(_fSel)						//перебирает найденные для текущего _exch источники геометрии с вызовом _fSel(idx,set)
	Animator.applyContent(_fSel)					//рекурсивно обходит узлы поддерева, начиная с текущего _exch, с вызовом _fSel(depth,idx,xch)
	Animator.applySource(_fSel)						//рекурсивно обходит вложенные слои, начиная с текущего, с вызовом _fSel(depth,idx,layer)
```

- Ненулевой результат фильтра `_fSel` будет передан через `applyBase` в `_fProp`.
Нулевой интерпретируется как сигнал игнорировать выбранный объект.
По умолчанию вместо результата передается `true`.

- *Анимация будет применена только к оконечным объектам.*

После завершения работы с аниматором можно прочесть итоговые тайминги анимации и параметры отложенной анимации.

```js
	Animator.getRes(_isGlb)		//возвращает результат в тайминге текущего объекта или в пересчете на cRoot
```

- Метод возвращает объект:

```js
{
	in							//момент окончания анимации входа
	out							//момент начала анимации выхода

	post : {					//параметры отложенной анимации выхода, формируются только для объектов без тайминга окончания при !SETUP.dur
		p						//массив имен, начиная от имени композиции, содержащей объект, до имени базового слоя и до имени целевого свойства
		r						//сдвиг момента начала анимации выхода относительно фактического времени окончания
								//остальные параметры формируются только для флага nor < 0
		f						//имя метода, 'changeTo|shape2keys'
		v						//целевое значение (только числа и массивы, кроме типов shape|text|marker -> undefined)
		d						//истинное значение длительности
		i						//степень интерполяции на границах перехода
		s						//скорость на границах перехода
	}
}
```

### Постобработка

Функция постобработки проверяет узел `_exch` на наличие `Animator` и сохраняет итоговые тайминги в `_exch` как свойства `in` и `out`.
Допускается корректировка этих значений извне в сторону увеличения смещений от границ соответствующего объекта. Для этого следует выставить значения указанных свойств предварительно.

По умолчанию тайминги всплывают сквозным образом через иерархию узлов дерева вплоть до корня с поэтапной корректировкой в сторону увеличения смещений.
Этим процессом можно управлять, используя в качестве предварительных значений объект с соответствующими флагами:

```js
{
	time						//альтернативное значение
	noch						//игнорировать тайминги дочерних узлов
	nome						//игнорировать тайминги аниматора
	nopt						//не передавать тайминги родительскому узлу
}
```

- Финальные значения `in` и `out` отображаются визуально в виде соответствующих маркеров слоя.
Параметры отложенной анимации выхода при наличии сериализуются в JSON и сохраняются как параметр `OUT` маркера `out`.

- *При передаче управления модулю `UPDATE` и реализации отложенной анимации значение `_exch.in` снимается с маркера.*

### Управление статическими параметрами

Модуль `DEFAULT` по умолчанию создает управляющий объект и сохраняет его как свойство `Static` текущего `_exch`.

```js
{
	mblur						//установка флага motionBlur, null|bool
	collapse					//установка флага collapseTransformation, cfg+style|null|bool
	is3d						//установка флага threeDLayer, cfg+prnt|null|bool

	ap							//установка anchorPoint, []+.space|3
	shift						//смещение position, []+.space|3
	orient						//установка orientation, []|'auto'; 'auto' -> автоориентация на активную камеру

	parent						//установка parent, false|null|L
	spread : [					//аргументы для разнесения слоев композиции-источника
		_span,					//диапазон по осям, (undef)|[x,y,z]|['x','y','z']; undef -> comp, '' -> relative
		_base,					//индекс базового слоя, idx|null
		_time,					//время, num|default
		_fSelect				//фильтр слоев, undef|func(L)|RE|'selected'|'enabled'
	]
	preset						//применение пресета .ffx, null|file

	drop()						//метод фактической установки всех перечисленных параметров

	dropped						//внутренний флаг проведенной установки
}
```

### Управление камерой

Модуль `INIT` по умолчанию создает пустой массив и сохраняет его как свойство `overs` объекта `_main`. На этапе сканирования массив `overs` заполняется ссылками на соответствующий контекст `SETUP` при обработке специальных объектов `OVER`.

Модуль `DEFAULT` по умолчанию сортирует массив `overs` по глобальному времени старта `gstart` и тегу идентификации `lvar`, добавляя свойство `sorted`, проводит поиск элемента, соответствующего по времени обрабатываемому объекту, и сохраняет его как свойство `over` текущего `_exch`. Этот параметр используется функцией постобработки для вынесения объекта в плоскость экрана.

Модуль `FINAL` перемещает активную камеру корневой композиции по сортированному массиву `overs` после обработки основной сцены.

<!-- --------------------------------------------------------------------------------------------------------------- -->
&nbsp;

---

## Рекомендации

При создании модулей `.jsxinc` рекомендуется использовать схему с принудительным вызовом `DEFAULT` и разделением на статическую и динамическую части. Такая структура сохраняет возможность централизованного управления объектами и упрощает отладку.
Использование аниматоров необходимо для корректной работы сквозных таймингов и отложенной анимации.
Использование геометрии опционально в зависимости от задач.

```js
/**
    dependencies & comments
*/

//================================================================================================================================================================
//FUNCTION BODY
//================================================================================================================================================================

var Context = this;
var Params = arguments[0];
var Stage = arguments[1];

if (Stage == 'operate' && Params instanceof Object) with (Params)
{
    _exec.bind(Context, Params);
    
    var Static = (_exec.call('DEFAULT'), _exch.Static);

//----------------------------------------------------------------------------------------------------------------------
//STATIC CODE START
//----------------------------------------------------------------------------------------------------------------------

        var geometry = (_exec.geometry(), _exch.geometry);
        var Animator = null;
        
        var delay = 0, tdur = '24';
        
//        PLACE VARIABLES HERE
        
        Static.mblur = true;
        
        if (geometry) {
            Static.ap = geometry.rel.ap;
            
            Animator = (_exec.animator(delay, tdur), _exch.Animator);
            
//            PLACE SETUP HERE
            
        } else {
            _exec.err();
        }

//----------------------------------------------------------------------------------------------------------------------
//STATIC CODE END
//----------------------------------------------------------------------------------------------------------------------

    Static.drop();

//----------------------------------------------------------------------------------------------------------------------
//DYNAMIC CODE START
//----------------------------------------------------------------------------------------------------------------------

        if (Animator) {
            
//            PLACE ANIMATION HERE
            
        }

//----------------------------------------------------------------------------------------------------------------------
//DYNAMIC CODE END
//----------------------------------------------------------------------------------------------------------------------

    _exch.parsed = true;
}
```

### Примечания

- Для отступов в тексте кода следует использовать 4 пробела вместо табуляции.
- Список параметров, доступных в данной конфигурации, рекомендуется помещать в `doc-comment` в заголовки модулей `INIT`, `DEFAULT` и `FINAL` соответственно уровню.

- Переименование слоев после сканирования ведет к ошибкам, т.к. `SETUP.lchain` фиксирует первоначальную цепочку имен в дереве.
- Подмена `SETUP.layer` может привести к ошибкам `Object is invalid`, если ссылка на слой сохранена в другом месте.
- Все операции с изменением стека слоев в рамках обработки конкретного объекта следует выполнять в пределах соответствующего обработчика.

<!-- --------------------------------------------------------------------------------------------------------------- -->
</body>
</html>